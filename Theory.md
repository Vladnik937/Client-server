Клиент-серверная архитектура

## ТЕМЫ:

-  Что такое клиент

-  Что такое сервер? Приведи пример, что может быть сервером сервера.

-  Что такое Interface

-  Что такое толстый клиент

-  Что такое тонкий клиент

-  Уровни клиент серверной архитектуры

-  Что такое балансировщик нагрузки (балансировщики)

-  Горячий резерв серверов 

-  Холодный резерв серверов

-  Web service 

-  Web server

-  Что такое микросервисная архитектура?

-  Прокси сервер? Приведи пример.

-  VPN? Приведи пример.

-  Что такое атака MAN in the Midl?

-  Что такое API?

-  Что такое REST API?

-  Требования к архитектуре Rest.

-  Что такое CRUD?

-  Чем GET отличается от POST?

-  Чем POST отличается от PUT?

-  Чем PUT отличается от PATCH?

-  Можно ли в POST передать данные и через URL и через Body?

-  Можно ли с помощью URLa передать данные на сервер?

-  Что такое идемпотентность?

-  В чем разница между безопасностью и идемпотентностью?

-  Что такое endpoint?

-  Что такое статус код сервера?

-  Какие существуют группы?

-  Какие ты знаешь 5 из 400?

-  Какие ты знаешь 5 из 500?

-  Какие ты знаешь Headers в Request?

-  Какие ты знаешь Headers в Responce?

-  Из чего состоит запрос HTTP - реквест?

-  Из чего состоят ответы HTTP -респонс?

-  Что такое и какая разница, Идентификация, Аутентификация, Авторизация?

-  Что происходит при валидации на сервере?

-  Что происходит при валидации на клиенте?

-  Что такое токен?

-  Где хранится токен?

-  Что такое токен авторизации? Объясни процесс токен авторизации?

-  Может ли быть авторизация без аутентификации? Приведи пример.

-  Что такое куки?

-  Что такое теплый клиент?

-  Что такое холодный клиент?

-  Что такое кеш?

-  Для чего используется кэширование страниц?

-  Для чего необходимо сбрасывать кэш и куки?

-  Что такое сессия?

-  Какие стореджи браузера ты знаешь?

-  В чем разница между сешин сторедж и локал сторедж?

-  Для чего необходимо сбрасывать кэш и куки?

-  Что такое REST

-  Что такое SOAP

-  Чем REST отличается от SOAP?

-  JSON Schema - это?

-  Что такое JSON и XML?

-  Каким форматом данных могут быть ключи в JSON?

-  Каким форматом данных могут быть значения в JSON?

-  Какие невалидные типы данных есть у JSON?

-  Что такое WSDL

-  Что такое WADL

-  Что такое логи?

-  Что такое логирование?

-  Перечислите типы логов

-  Механизм записи информации в логи

-  Зачем нужны логи? Какие инструменты знаете для сбора логов?

-  Привести примеры, когда QA-специалисту необходимо собрать логи с помощью Kibana

-  Что такое DNS?

-  Что такое IP адрес?

-  Что такое порт?

-  Что такое хост?

-  Что такое URL

-  В чем разница между URI, URL, URN ?

-  Из чего состоит url адрес?

-  Что происходит после ввода запроса в адресную строку?

-  Что такое HTTP?

-  Что такое HTTPS?

-  SSL и TLS - это?

-  TCP/IP - это?

-  Уровни TCP/IP?

-  Уровни OSI?

-  Что такое FTP?

-  Какую структуру имеет веб-страница?

-  Что такое HTML/CSS/JavaScript?

-  Что такое AJAX?

-  Что такое адаптивная и респонсивная верстка?

-  Как протестировать адаптивную верстку?

-  Как выполнить Debug страницы в браузере?

-  Что такое WebSocket и как проверить обрыв соединения?

-  Как узнать схему API проекта

-  Можно ли начать тестирование, если интерфейс (frontend) ещё не готов? Как?

-  Какие виды тестирования можно применить только к Web?

-  Каковы есть основные виды уязвимости веб-приложений?

-  Какие инструменты для тестирования Web performance client-side знаете?

## Что такое клиент-серверная архитектура

Клиент-серверная архитектура -- это модель взаимодействия двух сторон: клиента и сервера. Сервер предоставляет ресурсы и сервисы, а клиент отправляет запросы на их получение. Примеры клиент-серверных приложений -- это веб-браузеры (клиенты) и веб-серверы, где браузеры запрашивают страницы, а серверы отвечают на запросы.

## Что такое клиент

**Клиент** -- это устройство, программа или пользователь, который запрашивает и получает данные или услуги от другого устройства или программы, называемого сервером. Клиентская часть инициирует связь с сервером для получения определенных ресурсов, обработки данных или выполнения задач.

### **Основные особенности клиента:**

1. **Инициатор взаимодействия**: клиент обычно начинает взаимодействие, отправляя запрос серверу.

2. **Ограниченные ресурсы**: клиентская часть часто полагается на сервер для тяжелых операций, таких как хранение данных, вычисления или безопасность.

3. **Временное подключение**: клиент может подключаться к серверу на ограниченное время, например, для получения данных или обновлений, а затем отключаться.

### **Примеры клиентов:**

1. **Веб-браузер** (Chrome, Firefox, Safari): обращается к веб-серверам за веб-страницами.

2. **Мобильное приложение** (Instagram, YouTube): получает контент (фото, видео, текст) с серверов приложений.

3. **Игровой клиент** (например, Steam или клиент игры): подключается к игровым серверам для получения данных об игроках, игровой статистике и синхронизации.

4. **Почтовый клиент** (Outlook, Thunderbird): запрашивает и загружает сообщения с почтовых серверов.

### **Виды клиентов:**

1. **Толстый клиент** -- содержит большую часть логики и может выполнять сложные операции локально (например, графические редакторы или игры).

2. **Тонкий клиент** -- выполняет минимальные операции и максимально полагается на сервер (например, браузерные приложения).

### **Принцип работы клиента:**

1. Клиент отправляет запрос к серверу, например, запрос на веб-страницу.

2. Сервер принимает запрос, обрабатывает его и отправляет ответ.

3. Клиент принимает и отображает или обрабатывает ответные данные, например, отображая веб-страницу.

## Что такое сервер

Сервер -- это устройство или программа, предназначенные для предоставления различных ресурсов, услуг или данных другим устройствам или программам, которые называют клиентами. Серверы функционируют в режиме ожидания запросов и, получив запрос от клиента, обрабатывают его, а затем отправляют ответ. В клиент-серверной архитектуре серверы играют важнейшую роль, предоставляя централизованный доступ к ресурсам, облегчая их организацию и управление.

Серверы постоянно находятся в ожидании клиентских запросов и обрабатывают их по мере поступления. Благодаря высокой производительности и большим объемам памяти они способны обрабатывать множество запросов одновременно, обеспечивая стабильную и надежную работу. Их доступность и надежность обычно предполагают круглосуточную работу и наличие систем отказоустойчивости для минимизации риска потери данных. 

Серверы могут выполнять различные функции в зависимости от их типа. Веб-серверы, например, обрабатывают HTTP-запросы и предоставляют клиентам доступ к веб-страницам. Сервера баз данных управляют данными и отвечают на запросы, связанные с их извлечением и обновлением. Почтовые серверы занимаются отправкой и получением электронных писем, а файловые серверы обеспечивают централизованный доступ к файлам и документам. Также существуют игровые серверы, которые синхронизируют взаимодействие между игроками в реальном времени, и FTP-серверы, предназначенные для передачи файлов. API-серверы предлагают программный интерфейс для работы с данными и функциональностью через протоколы, такие как REST и GraphQL.

Работа сервера на практике может быть продемонстрирована на примере веб-сервера. Клиент, например, браузер, отправляет запрос на загрузку веб-страницы. Сервер принимает запрос, загружает необходимые данные, включая HTML, CSS и JavaScript файлы, и отправляет их клиенту. В итоге клиент получает данные и отображает веб-страницу.

Использование серверов позволяет централизованно управлять данными, облегчая их доступность и защиту. Серверы также обеспечивают безопасность информации через контроль доступа и защиту данных, что делает их важными элементами надежных информационных систем. Помимо этого, серверы позволяют легко масштабировать системы, увеличивая ресурсы или распределяя нагрузку между несколькими серверами, что особенно актуально при увеличении объема обрабатываемых данных и количества клиентов.

## Что такое Interface

Интерфейс -- это средство, с помощью которого различные компоненты системы взаимодействуют и обмениваются данными, используя заранее определенные правила и соглашения. Он определяет, какие функции и методы доступны для внешних компонентов, какой формат имеют запросы и ответы, и каким образом происходит взаимодействие. Интерфейс не описывает, как реализованы эти функции, а лишь определяет способ взаимодействия.

Основные аспекты интерфейса включают:

-  **Контракт**: интерфейс определяет "контракт", т.е. обязательные методы и параметры, которые должны соблюдаться сторонами, чтобы взаимодействие прошло успешно.

-  **Абстракция**: интерфейс скрывает внутреннюю реализацию функций и методов, предоставляя только доступ к необходимым элементам. Это позволяет менять внутреннюю логику без необходимости изменения интерфейса.

-  **Совместимость**: интерфейс обеспечивает совместимость между различными компонентами и позволяет им взаимодействовать, даже если они разработаны независимо друг от друга.

-  **Повторное использование и масштабируемость**: интерфейсы обеспечивают гибкость системы и позволяют легко добавлять или изменять компоненты, которые соответствуют интерфейсу.

### **Виды интерфейсов**

1. **Пользовательский интерфейс (UI)**: позволяет пользователям взаимодействовать с приложением или устройством. Обычно включает визуальные элементы, такие как кнопки, окна и меню.

2. **Программный интерфейс (API)**: определяет способ, с помощью которого программы и системы обмениваются данными. Включает методы, протоколы, пути запросов и формат данных. Например, REST API позволяет приложению запрашивать данные у сервера с помощью HTTP-запросов.

3. **Аппаратный интерфейс**: описывает физическое подключение и правила обмена данными между устройствами. Примером может служить интерфейс USB, обеспечивающий стандарт для подключения устройств к компьютеру.

4. **Интерфейсы данных**: способ обмена данными между системами и приложениями, часто включающий различные стандарты передачи данных (например, формат JSON или XML). Примером может быть интерфейс базы данных, такой как ODBC или JDBC, через который приложения получают доступ к данным в БД.

### **Пример интерфейса в объектно-ориентированном программировании (ООП)**

В ООП интерфейс -- это абстрактный тип данных, который определяет методы, но не их реализацию. Это своего рода "шаблон" для классов, реализующих интерфейс, которые обязаны предоставить конкретную реализацию методов.

Пример интерфейса на Java:

interface Vehicle {

    void startEngine();

    void stopEngine();

    int getNumberOfWheels();

}

В данном примере интерфейс Vehicle определяет методы startEngine, stopEngine и getNumberOfWheels, но не реализует их. Классы, такие как Car или Bicycle, могут реализовать этот интерфейс, определяя поведение этих методов.

### **Преимущества интерфейсов**

-  **Инкапсуляция**: интерфейсы позволяют скрыть внутренние детали реализации и предоставляют только необходимые элементы для взаимодействия.

-  **Гибкость и модульность**: интерфейсы позволяют легко изменять компоненты без нарушения работы других частей системы.

-  **Масштабируемость**: интерфейсы упрощают добавление новых компонентов, поскольку они могут следовать тем же правилам, что и существующие.

-  **Легкость тестирования**: интерфейсы позволяют создать подменные реализации для тестов, что упрощает проверку отдельных компонентов системы.

### **Пример интерфейса в клиент-серверной архитектуре (API)**

Рассмотрим пример интерфейса в виде REST API для сервиса погоды. Клиент делает запрос, а интерфейс сервиса определяет, как должен быть отправлен запрос и каким будет ответ.

**Запрос клиента:**

GET <https://api.weather.com/v1/current?location=London&units=metric>

Ответ сервера (интерфейс указывает, что данные возвращаются в формате JSON):

{

  "location": "London",

  "temperature": "15",

  "units": "Celsius",

  "condition": "Cloudy"

}

Клиент знает, как сформировать запрос, а сервер -- как обработать и вернуть данные в стандартизированном формате, что и обеспечивает интерфейс.

**Толстый клиент** и **тонкий клиент** -- это термины, описывающие разные подходы к распределению вычислительных задач между клиентом (устройством пользователя) и сервером в системе клиент-серверной архитектуры.

## Толстый клиент

Толстый клиент -- это приложение, которое выполняет основную часть вычислений на стороне клиента. Оно содержит большую часть бизнес-логики и функций, необходимых для работы, и взаимодействует с сервером лишь для обмена данными, хранения информации или синхронизации. Большинство вычислительных задач обрабатывается локально, что позволяет работать с приложением даже без постоянного подключения к серверу.

Примеры толстых клиентов включают:

-  **Десктопные приложения для обработки графики** (например, Adobe Photoshop, AutoCAD), которые выполняют рендеринг изображений и другие ресурсоемкие операции локально.

-  **Игровые приложения**, установленные на устройстве пользователя, которые обрабатывают графику и игровую логику, а к серверу обращаются только для синхронизации и передачи игровых данных.

## Тонкий клиент

Тонкий клиент -- это приложение, которое выполняет минимальные вычислительные задачи на стороне клиента, полагаясь на сервер для обработки бизнес-логики, вычислений и хранения данных. Это делает клиента «тонким», так как его основная задача -- передавать пользовательские запросы серверу и отображать результаты, полученные от сервера.

Примеры тонких клиентов включают:

-  **Веб-браузеры** (например, Chrome, Firefox), которые отображают веб-страницы, но полагаются на сервер для выполнения вычислений и обработки данных.

-  **Облачные приложения** (например, Google Docs), где все данные хранятся на сервере, а клиентская часть просто отображает интерфейс для работы с ними, отправляя изменения на сервер в реальном времени.

-  **Удаленные рабочие столы и виртуальные машины**, где клиент получает только изображение экрана, а все операции выполняются на сервере.

### **Сравнение толстого и тонкого клиента**

Толстый клиент обладает преимуществами в производительности, так как основные задачи обрабатываются локально, но требует больше ресурсов на стороне клиента. Тонкий клиент менее зависим от вычислительных мощностей устройства, но нуждается в постоянном подключении к серверу и хорошей сети, поскольку полагается на удаленную обработку данных и логики.

### **Когда выбирать толстый или тонкий клиент**

Толстый клиент подходит для ресурсоемких приложений, где важна независимость от подключения, например, графические редакторы или игры. Тонкий клиент удобен для приложений, требующих минимального использования локальных ресурсов и быстрой доставки обновлений, таких как корпоративные системы и веб-приложения.

## Уровни клиент-серверной архитектуры

Клиент-серверная архитектура может быть организована на нескольких уровнях, в зависимости от степени распределенности и сложности системы. Ниже приведены основные уровни клиент-серверной архитектуры:

### **Одноуровневая архитектура**

В одноуровневой архитектуре клиент и сервер находятся на одном уровне, что означает, что приложение выполняется на клиентском устройстве, и нет четкого разделения между клиентом и сервером. Обычно это локальные приложения, которые не требуют серверных ресурсов или взаимодействия с другими системами.

### **Двухуровневая архитектура**

В двухуровневой архитектуре клиент и сервер разделены на два уровня. Клиентская часть (обычно это пользовательский интерфейс) взаимодействует напрямую с серверной частью (базой данных или сервером приложений).

-  Клиент (толстый или тонкий) отвечает за обработку пользовательского ввода и отображение информации.

-  Сервер управляет данными и бизнес-логикой, выполняя запросы от клиента и отправляя результаты обратно.

Пример: настольное приложение, подключенное к базе данных для получения информации.

### **Многоуровневая архитектура**

Многоуровневая архитектура включает три или более уровней, обеспечивая более гибкую и масштабируемую структуру. Основные уровни обычно включают:

1. **Уровень представления**: пользовательский интерфейс, который взаимодействует с пользователями. Это может быть веб-приложение, мобильное приложение или десктопное приложение.

2. **Уровень бизнес-логики**: сервер приложений, который обрабатывает бизнес-логику и правила. Этот уровень принимает запросы от клиентского уровня, обрабатывает их и взаимодействует с уровнем данных.

3. **Уровень данных**: сервер базы данных, который управляет хранилищем данных, выполняет запросы на извлечение и изменение данных, а также обеспечивает защиту данных.

Пример: веб-приложение, где клиентский интерфейс работает с сервером приложений, который, в свою очередь, взаимодействует с базой данных для хранения и извлечения данных.

### **Четырехуровневая архитектура**

Четырехуровневая архитектура дополнительно выделяет уровень кэширования или API-серверов, которые могут обрабатывать запросы между клиентом и сервером приложений. Это улучшает производительность и безопасность системы. Основные уровни включают:

1. **Уровень представления**: пользовательский интерфейс.

2. **Уровень API**: сервер, который обрабатывает запросы от клиентского интерфейса и может кэшировать данные.

3. **Уровень бизнес-логики**: сервер приложений, обрабатывающий бизнес-логику.

4. **Уровень данных**: сервер базы данных.

### **Преимущества многоуровневой архитектуры**

Многоуровневая архитектура позволяет разделить ответственность между компонентами, что делает систему более гибкой и масштабируемой. Каждый уровень может быть независимо масштабирован, что упрощает управление нагрузкой и повышает отказоустойчивость системы. Она также упрощает обновления и модификации, поскольку изменения на одном уровне минимально влияют на другие уровни.

## Что такое балансировщики нагрузки

Балансировщик нагрузки -- это компонент, который распределяет входящий сетевой трафик между несколькими серверами или ресурсами, чтобы обеспечить эффективное использование ресурсов, повысить производительность и обеспечить высокую доступность приложений. Он служит промежуточным слоем между клиентами и серверами, позволяя управлять нагрузкой и оптимизировать работу системы.

### **Основные функции балансировщика нагрузки:**

1. **Распределение нагрузки**: балансировщик принимает запросы от клиентов и распределяет их между доступными серверами. Это позволяет избежать перегрузки отдельных серверов и обеспечивает более равномерное использование ресурсов.

2. **Высокая доступность**: если один из серверов выходит из строя, балансировщик автоматически перенаправляет трафик на другие доступные серверы, обеспечивая непрерывную работу приложения и минимальное время простоя.

3. **Увеличение производительности**: распределение нагрузки помогает оптимизировать время отклика приложений, снижая время ожидания для пользователей и повышая общую производительность системы.

4. **Мониторинг состояния серверов**: балансировщики нагрузки могут отслеживать состояние серверов и их производительность. Если сервер не отвечает или работает неэффективно, балансировщик исключает его из списка доступных ресурсов.

5. **Безопасность**: балансировщик может служить дополнительным уровнем защиты, скрывая внутреннюю инфраструктуру и обеспечивая защиту от DDoS-атак путем фильтрации трафика.

### **Типы балансировщиков нагрузки:**

1. **Аппаратные балансировщики**: специализированные устройства, которые обеспечивают высокую производительность и надежность. Они часто используются в крупных центрах обработки данных.

2. **Программные балансировщики**: программные решения, которые можно развернуть на стандартных серверах. Они могут быть гибкими и более доступными для небольших и средних компаний. Примеры включают NGINX, HAProxy и Apache Traffic Server.

3. **Облачные балансировщики**: услуги, предоставляемые облачными провайдерами, которые обеспечивают автоматическое масштабирование и управление нагрузкой. Примеры включают AWS Elastic Load Balancing, Azure Load Balancer и Google Cloud Load Balancing.

### **Алгоритмы балансировки нагрузки:**

1. **Round Robin**: запросы распределяются по серверам по кругу. Каждый сервер получает запрос по очереди, что подходит для равномерной нагрузки.

2. **Least Connections**: запросы направляются на сервер с наименьшим количеством активных соединений. Этот алгоритм полезен, когда серверы имеют разные уровни производительности.

3. **IP Hash**: алгоритм направляет запросы на основе IP-адреса клиента. Это обеспечивает, что запросы от одного клиента всегда обрабатываются одним и тем же сервером, что может быть полезно для сеансовых данных.

4. **Random**: запросы распределяются случайным образом между серверами. Этот метод проще в реализации, но может привести к неравномерной нагрузке.

### **Преимущества использования балансировщика нагрузки:**

-  **Увеличенная доступность**: повышает отказоустойчивость системы, минимизируя время простоя.

-  **Скалируемость**: позволяет добавлять новые серверы по мере роста нагрузки.

-  **Оптимизация ресурсов**: эффективное использование серверов и ресурсов.

-  **Улучшение пользовательского опыта**: снижение времени отклика и повышение скорости работы приложений.

В целом, балансировщик нагрузки является важным элементом современной архитектуры приложений, обеспечивая надежность, производительность и безопасность систем.

Горячий и холодный резерв серверов -- это два подхода к обеспечению отказоустойчивости и надежности серверной инфраструктуры. Каждый из этих подходов имеет свои характеристики и области применения.

## Горячий резерв серверов

Горячий резерв -- это метод, при котором резервные серверы постоянно активны и готовы к работе в любой момент. Они синхронизированы с основными серверами и могут мгновенно принять на себя нагрузку в случае сбоя. Основные характеристики горячего резерва:

-  **Непрерывная работа**: резервные серверы работают в реальном времени, получая те же данные, что и основные серверы.

-  **Мгновенный переход**: в случае сбоя основного сервера, резервный сервер может сразу же взять на себя его функции без потери данных или времени.

-  **Высокие затраты**: необходимость поддерживать два активных сервера приводит к увеличению затрат на оборудование и обслуживание.

**Пример**: Банковская система, где необходима высокая доступность и отказоустойчивость. Если основной сервер, обрабатывающий транзакции, выходит из строя, резервный сервер (горячий резерв) немедленно берет на себя обработку запросов, что позволяет избежать потери данных и обслуживания клиентов.

## Холодный резерв серверов

Холодный резерв -- это метод, при котором резервные серверы не активны в обычное время и требуют ручного вмешательства для активации в случае сбоя. Основные характеристики холодного резерва:

-  **Неактивные серверы**: резервные серверы не работают до тех пор, пока не потребуется их активировать.

-  **Время восстановления**: переключение на резервный сервер может занять время, так как требуется активировать его и, возможно, синхронизировать данные.

-  **Низкие затраты**: так как резервные серверы не работают постоянно, затраты на их обслуживание и энергопотребление ниже.

**Пример**: Компания, занимающаяся веб-хостингом, может иметь холодный резервный сервер, который используется только в случае сбоя основного сервера. В случае аварии администратор может включить резервный сервер, загрузить последнюю резервную копию данных и перенаправить трафик, но это займет некоторое время, и в этот период может наблюдаться недоступность сайта.

## Web Service

Веб-сервис -- это программный интерфейс, который позволяет различным приложениям обмениваться данными и выполнять операции по сети. Веб-сервисы следуют определенным стандартам и протоколам, обеспечивающим взаимодействие между системами, даже если они написаны на разных языках программирования или работают на разных платформах.

**Ключевые характеристики**:

1. **Стандарты и протоколы**: Веб-сервисы могут использовать различные протоколы и форматы данных, включая:

   -  **SOAP (Simple Object Access Protocol)**: Протокол обмена сообщениями, который использует XML для передачи данных. Часто используется в корпоративных средах.

   -  **REST (Representational State Transfer)**: Архитектурный стиль, который использует стандартные HTTP-методы (GET, POST, PUT, DELETE) для взаимодействия с ресурсами. Данные обычно передаются в формате JSON или XML.

   -  **WSDL (Web Services Description Language)**: Язык описания веб-сервисов, который предоставляет информацию о доступных методах и параметрах.

2. **Интероперабельность**: Веб-сервисы позволяют взаимодействовать различным системам, независимо от их внутренней реализации, языка программирования или платформы.

3. **Удаленный доступ**: Они предоставляют доступ к функциональности и данным, размещенным на сервере, через интернет.

4. **Пример**:

   -  Веб-сервис для получения информации о пользователях из базы данных. Клиентское приложение может отправить HTTP-запрос к веб-сервису, который возвращает данные о пользователе в формате JSON. Например, запрос к <https://api.example.com/users/123> может вернуть данные о пользователе с ID 123.

## Web Server

Веб-сервер -- это программное или аппаратное обеспечение, которое принимает и обрабатывает HTTP-запросы от клиентов (обычно веб-браузеров) и отправляет им запрашиваемый контент (веб-страницы, изображения и т. д.). Веб-серверы могут также обрабатывать динамические запросы, выполняя серверные скрипты.

**Ключевые характеристики**:

1. **Хранение контента**: Веб-серверы хранят статические файлы (HTML, CSS, изображения) и могут генерировать динамические страницы с помощью серверного программирования (например, PHP, Python, Ruby).

2. **Обработка HTTP-запросов**: Веб-сервер получает HTTP-запросы, определяет, какой контент запрашивается, и возвращает соответствующий ответ. Он может также обрабатывать коды состояния, такие как 200 (ОК), 404 (Не найдено) и 500 (Внутренняя ошибка сервера).

3. **Выполнение приложений**: Многие веб-серверы могут обрабатывать серверные скрипты и генерировать динамические страницы на основе входящих данных. Например, когда пользователь заполняет форму, веб-сервер может выполнить соответствующий скрипт и отобразить результат.

4. **Пример**:

   -  Веб-сервер Apache HTTP Server, который может обслуживать статические веб-страницы и запускать динамические веб-приложения. Например, сервер может возвращать файл index.html по запросу GET /index.html.

### **Сравнение Web Service и Web Server**

-  **Функция**: Веб-сервис предоставляет интерфейс для взаимодействия и обмена данными между приложениями, в то время как веб-сервер отвечает за доставку веб-контента клиентам.

-  **Протоколы**: Веб-сервисы используют протоколы, такие как SOAP или REST, для передачи данных, в то время как веб-серверы используют HTTP для обработки запросов.

-  **Применение**: Веб-сервисы используются для интеграции различных приложений и систем, тогда как веб-серверы предназначены для обслуживания веб-сайтов и приложений.

## Прокси сервер

Прокси и прокси-сервер -- это важные компоненты сетевой архитектуры, которые обеспечивают промежуточное взаимодействие между клиентами и серверами. 

Прокси-сервер представляет собой сервер, который действует как посредник между клиентами (например, веб-браузерами) и интернет-ресурсами. Он принимает запросы от клиентов, обрабатывает их и перенаправляет на целевой сервер. После получения ответа от сервера прокси-сервер передает эти данные обратно клиенту. Прокси-серверы могут использоваться для различных целей, включая повышение производительности, безопасность и анонимность пользователей.

Существует несколько типов прокси-серверов, каждый из которых имеет свои особенности и предназначение. Один из наиболее распространенных типов -- это веб-прокси, который работает на уровне HTTP и используется для доступа к веб-страницам. Он может кешировать запрашиваемые страницы, что снижает время загрузки и уменьшает нагрузку на сеть.

Анонимные прокси-серверы помогают скрыть IP-адрес пользователя, обеспечивая анонимность в интернете. Они могут быть полезны для обхода блокировок и доступа к ресурсам, которые могут быть недоступны в определенных регионах.

Еще один тип -- это прозрачные прокси, которые не требуют изменений в конфигурации клиента. Они могут использоваться для фильтрации контента, блокировки нежелательных сайтов и мониторинга интернет-трафика в корпоративных сетях.

Прокси-серверы также могут улучшать безопасность сети, служа барьером между клиентами и потенциальными угрозами. Они могут фильтровать вредоносный трафик, проверять содержимое запросов и отвечать на них. 

Кроме того, прокси-серверы могут использоваться для балансировки нагрузки. В этом случае прокси принимает запросы от клиентов и распределяет их между несколькими серверами, что позволяет избежать перегрузки и обеспечить более эффективное использование ресурсов.

Прокси-серверы могут быть настроены для работы с различными протоколами, такими как HTTP, HTTPS, FTP и другие. Важно отметить, что работа с HTTPS требует специальных настроек, так как трафик зашифрован, и прокси должен поддерживать соответствующие методы обработки.

Преимущества использования прокси-серверов включают улучшение производительности за счет кэширования, повышение безопасности и возможность контроля доступа. Однако стоит учитывать, что использование прокси также может привести к некоторым недостаткам, таким как задержки в обработке запросов, возможность утечки конфиденциальной информации или сбои в работе, если прокси-сервер недоступен.

В целом, прокси и прокси-серверы играют важную роль в сетевой инфраструктуре, обеспечивая различные функции, от повышения производительности до обеспечения безопасности и анонимности пользователей.

## Основные функции VPN

VPN (Virtual Private Network) -- это технология, обеспечивающая защищенное и приватное соединение между устройством пользователя и интернетом. VPN создает зашифрованный туннель для передачи данных, что позволяет скрыть активность в сети и защитить личную информацию от посторонних глаз, таких как хакеры, провайдеры интернет-услуг или государственные органы.

VPN шифрует данные, передаваемые между устройством пользователя и VPN-сервером, что делает их недоступными для перехвата. Это особенно важно при использовании общественных Wi-Fi сетей, где злоумышленники могут легко получить доступ к личной информации.

Кроме того, VPN позволяет пользователям маскировать свой IP-адрес. Когда пользователь подключается к VPN, его интернет-трафик проходит через сервер VPN, и IP-адрес заменяется на IP-адрес этого сервера. Это создает иллюзию, что пользователь находится в другой географической локации, что позволяет обходить географические ограничения и блокировки контента. Например, пользователи могут получить доступ к контенту, который доступен только в определенных странах.

VPN также обеспечивает дополнительный уровень безопасности для корпоративных сетей. Компании могут использовать VPN для того, чтобы предоставить своим сотрудникам безопасный удаленный доступ к корпоративным ресурсам, что особенно актуально в условиях увеличения удаленной работы. Это позволяет сотрудникам безопасно подключаться к внутренним системам компании из любого места.

### **Виды VPN**

Существует несколько типов VPN, включая:

1. **Remote Access VPN**: Этот тип VPN позволяет пользователям подключаться к сети через интернет. Например, сотрудники могут использовать VPN для доступа к корпоративным ресурсам, находясь вне офиса.

2. **Site-to-Site VPN**: Это соединение между двумя или более сетями. Например, филиалы компании могут соединяться между собой через защищенное соединение, используя VPN.

3. **Mobile VPN**: Этот тип VPN специально предназначен для мобильных устройств, обеспечивая безопасное подключение даже при изменении сетей, например, при переходе с Wi-Fi на мобильную сеть.

### **Преимущества и недостатки**

Преимущества использования VPN включают:

-  Защита конфиденциальности: шифрование данных и маскировка IP-адреса помогают защитить личные данные от посторонних.

-  Доступ к заблокированному контенту: пользователи могут обойти географические ограничения и получить доступ к контенту из других регионов.

-  Безопасный удаленный доступ: компании могут обеспечить безопасность своих данных и систем, предоставляя сотрудникам удаленный доступ через VPN.

Однако есть и недостатки:

-  Замедление скорости соединения: шифрование и маршрутизация трафика через VPN-сервер могут привести к снижению скорости интернет-соединения.

-  Не все VPN-сервисы одинаково безопасны: некоторые могут вести журналы активности пользователей или использовать слабые методы шифрования, что может подвергать риску конфиденциальность.

## Атака "Man in the Middle" 

Атака "Man in the Middle" (MitM) -- это тип кибератаки, при которой злоумышленник перехватывает, изменяет или подслушивает коммуникацию между двумя сторонами, не зная об этом ни одна из них. Основная цель такой атаки -- получение доступа к конфиденциальной информации, такой как пароли, номера кредитных карт, личные данные и другие важные сведения.

### **Как работает атака MitM?**

Злоумышленник может реализовать атаку MitM несколькими способами:

1. **Перехват трафика**: Злоумышленник может использовать общественную сеть Wi-Fi для перехвата трафика. Например, он может установить фальшивую точку доступа Wi-Fi, и, подключившись к ней, получить доступ к данным пользователей, которые взаимодействуют с интернет-ресурсами.

2. **ARP Spoofing**: В этом случае злоумышленник отправляет ложные ARP-ответы в локальную сеть, связывая свой MAC-адрес с IP-адресом другого устройства. Это позволяет ему перехватывать трафик, направляемый к этому устройству.

3. **SSL Stripping**: Злоумышленник может попытаться переориентировать пользователя с безопасного HTTPS-соединения на незащищенное HTTP-соединение, тем самым подслушивая передаваемые данные.

4. **Session Hijacking**: Злоумышленник может украсть идентификатор сессии (например, куки-файлы) и использовать его для доступа к учетной записи пользователя на веб-сайте.

### **Примеры атак MitM**

Атаки MitM могут происходить в различных сценариях, включая:

-  Подслушивание и модификация электронной почты, чатов и других форм общения.

-  Перехват данных в процессе онлайн-платежей, что может привести к утечке финансовой информации.

-  Установка вредоносного ПО на устройство пользователя через незашифрованное соединение.

### **Защита от атак MitM**

Для защиты от атак MitM можно использовать различные методы и инструменты:

1. **Шифрование**: Использование протоколов шифрования, таких как HTTPS и VPN, значительно снижает риск перехвата данных.

2. **Аутентификация**: Двухфакторная аутентификация (2FA) добавляет дополнительный уровень безопасности, требуя подтверждения доступа с другого устройства.

3. **Использование виртуальных частных сетей (VPN)**: VPN шифрует весь интернет-трафик, что делает его менее доступным для перехвата.

4. **Предостережение при использовании общественных Wi-Fi сетей**: Пользователям следует избегать выполнения критически важных операций, таких как онлайн-банкинг, при использовании открытых или общественных Wi-Fi.

5. **Мониторинг сетевого трафика**: Установление систем мониторинга может помочь в обнаружении подозрительной активности в сети.

Атака "Man in the Middle" представляет собой серьезную угрозу для безопасности данных в сети. Понимание того, как эти атаки работают и как можно защититься от них, является важным шагом к обеспечению безопасности личной информации и бизнес-данных.

## Что такое API

API (Application Programming Interface) -- это набор правил и протоколов, который позволяет различным программным приложениям взаимодействовать друг с другом. API определяет, как запросы к определенным функциям должны быть структурированы, какие данные могут быть переданы и как обрабатываются ответы. Это обеспечивает стандартизированный способ для различных приложений, систем и компонентов обмениваться информацией и функциональностью.

### **Основные характеристики API**

1. **Функциональность**: API предоставляет доступ к определенным функциям или данным, которые могут быть использованы другими приложениями. Например, API может позволить приложению получить информацию о погоде, отправить сообщения или обработать платежи.

2. **Протоколы**: API определяет, каким образом приложения должны общаться. Это может быть HTTP для веб-API или другие протоколы, такие как SOAP или gRPC.

3. **Формат данных**: API определяет формат, в котором данные передаются между клиентом и сервером. Наиболее распространенные форматы -- это JSON (JavaScript Object Notation) и XML (eXtensible Markup Language).

### **Типы API**

Существует несколько типов API:

-  **Веб-API**: Позволяет взаимодействовать с веб-приложениями через интернет. Примеры включают RESTful API и GraphQL API. REST API часто используется для работы с ресурсами, предоставляя стандартные методы HTTP (GET, POST, PUT, DELETE) для взаимодействия с данными.

-  **Библиотечные API**: Предоставляют функции и методы для разработки приложений с использованием определенных библиотек или фреймворков. Например, API для библиотек jQuery или React.

-  **Операционные системы API**: Позволяют приложениям взаимодействовать с функциями операционной системы, такими как доступ к файловой системе или управление устройствами. Примеры включают WinAPI для Windows или POSIX для Unix-подобных систем.

### **Пример использования API**

Представим, что вы разрабатываете приложение для погоды. Вместо того чтобы собирать данные о погоде самостоятельно, вы можете использовать API от сервиса погоды. Ваше приложение отправляет HTTP-запрос на API с указанным местоположением, и API возвращает данные о текущей погоде в формате JSON.

Пример запроса к погодному API:

GET <https://api.weather.com/v3/weather/current?location=London&apiKey=YOUR_API_KEY>

Пример ответа API в формате JSON:

{

  "location": "London",

  "temperature": "15",

  "units": "Celsius",

  "condition": "Cloudy"

}

Ваше приложение может легко обработать эти данные и отобразить информацию пользователю.

### **Преимущества использования API**

Использование API предлагает множество преимуществ, включая:

-  **Упрощение разработки**: Позволяет разработчикам сосредоточиться на основной функциональности приложения, не тратя время на реализацию сторонних функций.

-  **Повышение совместимости**: Позволяет различным приложениям и системам взаимодействовать друг с другом, даже если они написаны на разных языках программирования или работают на различных платформах.

-  **Расширяемость**: API позволяет легко добавлять новые функции и интеграции в приложение без необходимости переписывать его с нуля.

## Что такое REST API?

### **1\. Клиент-серверная архитектура**

В REST API клиент (например, браузер или мобильное приложение) и сервер (серверное приложение) разделены. Клиент отправляет запросы на сервер, а сервер обрабатывает их и возвращает ответы. Это разделение позволяет независимо развивать и обновлять клиентскую и серверную части системы.

### **2\. Отсутствие состояния (Statelessness)**

Каждый запрос от клиента должен содержать всю информацию, необходимую для его выполнения. Сервер не сохраняет состояние между запросами. Это означает, что сервер не запоминает, какие действия выполнял клиент ранее. Например, для аутентификации клиент должен отправлять токен или другую идентификационную информацию в каждом запросе.

**Преимущества**:

-  Легче масштабировать сервер, так как он не отслеживает состояние клиентов.

-  Серверы могут обрабатывать запросы параллельно и независимо.

### **3\. Кэширование**

Кэширование помогает уменьшить нагрузку на сервер и ускорить доступ к ресурсам. Сервер может указать, что ответ на определённый запрос можно кэшировать, добавляя специальные заголовки, такие как Cache-Control.

**Пример**:

Cache-Control: max-age=3600

Этот заголовок говорит клиенту, что ответ можно кэшировать в течение 3600 секунд (1 час).

### **4\. Единообразие интерфейса (Uniform Interface)**

REST API предоставляет единообразный интерфейс, что делает его удобным для разработки и использования. Это достигается за счет стандартизированных методов HTTP:

-  **GET**: Используется для получения данных.

-  **POST**: Для создания новых ресурсов.

-  **PUT**: Для обновления или замены существующих ресурсов.

-  **DELETE**: Для удаления ресурсов.

**Пример запроса**:

-  **GET /users** -- получение списка пользователей.

-  **POST /users** -- создание нового пользователя.

-  **PUT /users/1** -- обновление информации о пользователе с ID 1.

-  **DELETE /users/1** -- удаление пользователя с ID 1.

### **5\. Слои системы (Layered System)**

REST API поддерживает многоуровневую архитектуру, где различные уровни (например, балансировщики нагрузки, серверы безопасности, кеширующие сервера) могут быть добавлены между клиентом и сервером. Это повышает безопасность, масштабируемость и отказоустойчивость системы.

### **6\. Код по требованию (Code on Demand)**

Этот принцип позволяет серверу передавать клиенту исполняемый код, например, JavaScript, который клиент может выполнять. Это необязательный принцип и используется не так часто.

### **7\. Структура URI**

В REST API ресурсы идентифицируются с помощью URI (Uniform Resource Identifier). URI должен быть понятным и интуитивно понятным.

**Примеры URI**:

-  /users -- для работы с коллекцией пользователей.

-  /users/1 -- для работы с конкретным пользователем с ID 1.

### **8\. Форматы данных**

REST API обычно возвращает данные в форматах, удобных для чтения и парсинга, таких как:

-  **JSON** (наиболее популярный формат благодаря своей легкости и читаемости)

-  **XML** (используется реже, но все еще актуален для некоторых приложений)

-  **HTML** (если API возвращает готовый для отображения контент)

**Пример JSON-ответа**:

json

{

  "id": 1,

  "name": "John Doe",

  "email": "[john.doe@example.com](mailto:john.doe@example.com)"

}

### **9\. Обработка ошибок**

REST API должен корректно обрабатывать ошибки и возвращать соответствующие HTTP-статусы, такие как:

-  **200 OK** -- запрос выполнен успешно.

-  **201 Created** -- ресурс успешно создан.

-  **400 Bad Request** -- ошибка в запросе клиента.

-  **401 Unauthorized** -- клиент не авторизован.

-  **404 Not Found** -- запрошенный ресурс не найден.

-  **500 Internal Server Error** -- ошибка на стороне сервера.

**Пример ответа на ошибку**:

json

{

  "error": "User not found",

  "code": 404

}

### **10\. Безопасность REST API**

REST API должен обеспечивать защиту данных и пользователей. Основные меры безопасности включают:

-  **Аутентификация**: Например, с использованием токенов (JWT), OAuth.

-  **Шифрование**: Все данные передаются через HTTPS для защиты от перехвата.

-  **Авторизация**: Определение, какие действия разрешены пользователю.

### **Примеры использования REST API:**

1. **Социальные сети**:

   -  Запрос списка друзей.

   -  Публикация статуса.

2. **Интернет-магазины**:

   -  Просмотр товаров.

   -  Оформление заказа.

3. **Банковские приложения**:

   -  Проверка баланса.

   -  Перевод средств.

REST API широко используется благодаря своей гибкости, простоте и масштабируемости. Это делает его идеальным выбором для множества современных веб-приложений и сервисов.

## Требования к архитектуре Rest.

Архитектура REST (Representational State Transfer) опирается на несколько ключевых принципов и требований. Вот основные из них:

### **1\. Клиент-серверная модель**

-  **Разделение ответственности**: Клиент и сервер независимы. Клиент отвечает за интерфейс пользователя, а сервер -- за управление данными и бизнес-логику.

### **2\. Отсутствие состояния (Statelessness)**

-  **Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для выполнения запроса**. Сервер не сохраняет состояние сессии между запросами. Это упрощает масштабирование и делает систему более устойчивой.

### **3\. Кэшируемость**

-  **Ответы от сервера могут быть кэшированы клиентом**. Сервер должен указывать, какие ответы можно кэшировать, а какие нет, чтобы повысить производительность и снизить нагрузку на сервер.

### **4\. Единообразие интерфейса (Uniform Interface)**

-  **Определённый набор стандартов и соглашений**:

   -  **Идентификация ресурсов**: Все ресурсы идентифицируются через URI.

   -  **Манипуляция ресурсами через представление**: Используются стандартные HTTP-методы (GET, POST, PUT, DELETE) для операций над ресурсами.

   -  **Самоописываемые сообщения**: Сообщения содержат достаточную информацию для выполнения действия (например, тип данных в заголовке Content-Type).

   -  **Гипермедиа как движок приложения (HATEOAS)**: Клиент взаимодействует с приложением исключительно через гиперссылки, предоставленные сервером.

### **5\. Многоуровневая система (Layered System)**

-  **Архитектура поддерживает разделение на уровни**: Клиент не знает, общается ли он напрямую с сервером или через промежуточные слои, такие как прокси-серверы или балансировщики нагрузки.

### **6\. Код по требованию (Code on Demand, необязательно)**

-  **Сервер может передавать исполняемый код клиенту**, например скрипты JavaScript, для динамического изменения функциональности клиента. Этот принцип используется по мере необходимости.

### **7\. Ресурсо-ориентированный подход**

-  **Каждый ресурс должен иметь четко определенный URI** и быть представлен в различных форматах (JSON, XML, HTML и т.д.).

### **Преимущества REST**

-  Простота и гибкость.

-  Хорошо масштабируется.

-  Легко интегрируется с существующими веб-технологиями.

-  Широко поддерживается.

Эти требования делают REST надежным и широко применимым стандартом для построения веб-сервисов.

## Что такое CRUD?

CRUD -- это базовый набор операций, которые выполняются над данными в большинстве приложений, работающих с базами данных или API. Аббревиатура расшифровывается как Create, Read, Update, Delete, что означает «создать», «прочитать», «обновить» и «удалить». Эти действия представляют собой фундаментальные операции для управления данными в системе.

Когда вы работаете с каким-либо приложением, например, системой управления задачами, почти все действия пользователя сводятся к выполнению одной из этих операций. Если вы создаете новую задачу, вы выполняете операцию **Create**. Когда вы просматриваете список задач, это **Read**. Если вам нужно изменить описание задачи или отметить её как выполненную, вы делаете **Update**. И, наконец, если задача больше не нужна, вы её удаляете -- это **Delete**.

Теперь представьте, как это работает в контексте RESTful API, который взаимодействует с базой данных через HTTP-запросы. Каждая из операций CRUD соответствует определённому HTTP-методу:

1. **Create** -- создаём новый ресурс. Это делается с помощью метода POST. Например, чтобы добавить нового пользователя в систему, отправляется запрос POST /users с данными нового пользователя в теле запроса.

2. **Read** -- получаем данные. Для этого используется метод GET. Например, чтобы получить информацию о всех пользователях, вы делаете запрос GET /users. Если нужен конкретный пользователь, запрашиваете GET /users/1, где 1 -- это ID пользователя.

3. **Update** -- обновляем существующие данные. Здесь обычно используются методы PUT или PATCH. PUT применяется для полного обновления ресурса, а PATCH -- для частичного. Если вы хотите изменить электронную почту пользователя с ID 1, вы можете отправить запрос PATCH /users/1 с обновленной информацией.

4. **Delete** -- удаляем данные. Это делается через метод DELETE. Например, DELETE /users/1 удалит пользователя с ID 1 из базы данных.

Эти четыре операции составляют основу практически любой системы управления данными. CRUD позволяет создать простую и логичную структуру для разработки приложений. Вы можете видеть, как каждое из этих действий прямо коррелирует с базовыми задачами, которые вы выполняете при работе с данными: добавление новой информации, её просмотр, обновление и удаление ненужного.

В реальной жизни примером CRUD может служить простая система управления контактами. Вы создаете новый контакт (Create), просматриваете список контактов (Read), обновляете номер телефона существующего контакта (Update), и удаляете контакт, если он больше не нужен (Delete).

CRUD -- это не просто концепция, а основа, которая помогает разработчикам структурировать взаимодействие с данными и делать приложения удобными и функциональными.

## Методы GET, POST, PUT, PATCH

### **Различие между GET и POST**

1. **GET**:

   -  **Цель**: Используется для получения данных с сервера.

   -  **Передача данных**: Данные передаются в URL, обычно в виде строки запроса (query string), например: GET /search?q=example.

   -  **Идемпотентность**: Метод идемпотентен, что означает, что повторные запросы с одинаковыми параметрами всегда возвращают тот же результат и не изменяют состояние сервера.

   -  **Кэширование**: Ответы на GET запросы могут кэшироваться, так как они не изменяют данные.

   -  **Ограничение на длину URL**: Некоторые серверы или браузеры могут ограничивать длину URL.

2. **POST**:

   -  **Цель**: Используется для отправки данных на сервер с целью создания нового ресурса или выполнения действия.

   -  **Передача данных**: Данные передаются в теле запроса (body), а не в URL.

   -  **Неидемпотентность**: Повторные POST запросы могут привести к созданию нескольких одинаковых ресурсов, так как каждый запрос может быть обработан отдельно.

   -  **Кэширование**: Обычно POST запросы не кэшируются.

   -  **Передача данных через URL**: Технически возможно передавать данные и через URL, и через тело запроса, но это не рекомендуется. Обычно параметры в URL используются для указания цели запроса, а данные передаются в теле.

### **Различие между POST и PUT**

1. **POST**:

   -  **Цель**: Предназначен для создания нового ресурса. Сервер определяет местоположение ресурса и возвращает его URI.

   -  **Идемпотентность**: Неидемпотентен. Повторные вызовы могут создавать несколько ресурсов.

   -  **Примеры**:

      -  Создание нового пользователя: POST /users с данными нового пользователя в теле запроса.

2. **PUT**:

   -  **Цель**: Используется для обновления существующего ресурса или создания ресурса, если он не существует. Клиент предоставляет полный ресурс вместе с его URI.

   -  **Идемпотентность**: Идемпотентен. Повторные вызовы с одинаковыми данными всегда приводят к одному и тому же результату.

   -  **Примеры**:

      -  Обновление данных пользователя: PUT /users/1 с полными данными пользователя.

### **Различие между PUT и PATCH**

1. **PUT**:

   -  **Цель**: Полностью заменяет ресурс. Клиент отправляет полный набор данных для ресурса.

   -  **Идемпотентность**: Идемпотентен. Повторные запросы с одинаковыми данными дают тот же результат.

   -  **Пример**:

      -  PUT /users/1 с полными данными пользователя.

2. **PATCH**:

   -  **Цель**: Используется для частичного обновления ресурса. Клиент отправляет только те данные, которые необходимо изменить.

   -  **Идемпотентность**: Обычно считается идемпотентным, но зависит от реализации.

   -  **Пример**:

      -  Обновление только электронной почты пользователя: PATCH /users/1 с данными { "email": "[newemail@example.com](mailto:newemail@example.com)" }.

## Можно ли в POST передать данные и через URL и через Body?

Технически **POST** запрос может передавать данные как через **URL**, так и через **Body**. Однако это не является общепринятой практикой и используется редко.

### **Передача данных через URL и Body**

1. **Данные в URL**:

Данные передаются в строке запроса (query string), например:

http\
POST /submit?userId=123 HTTP/1.1

Host: [example.com](http://example.com)

-  Это используется для указания параметров, которые нужны серверу для обработки запроса, например, идентификатор ресурса или тип операции.

1. **Данные в Body**:

Основные данные передаются в теле запроса, например:\
{

  "name": "John Doe",

  "email": "[john@example.com](mailto:john@example.com)"

}

### **Зачем это может использоваться?**

-  **Фильтрация или настройка запроса**: Данные в URL могут использоваться для фильтрации, сортировки или указания контекста запроса, тогда как основная информация передается в теле.

-  **Совместимость**: Некоторые API могут поддерживать такие запросы для удобства или совместимости с существующими системами.

### **Почему это не рекомендуется?**

1. **Неоднозначность**:

   -  Данные могут дублироваться или противоречить друг другу. Например, если userId передан и в URL, и в теле, серверу нужно будет определить, какой из них использовать.

2. **Безопасность**:

   -  Данные в URL видны в адресной строке, логах сервера и истории браузера, что может привести к утечке чувствительной информации.

3. **Ограничения на длину URL**:

   -  URL имеет ограничение на длину, что делает передачу больших объемов данных через URL неэффективной.

4. **Сложность**:

   -  Увеличивается сложность обработки запроса на стороне сервера, так как нужно обрабатывать и данные из URL, и из тела запроса.

### **Лучшие практики**

-  **POST** запросы лучше использовать для передачи данных в теле запроса, особенно если объем данных значительный или данные содержат чувствительную информацию.

-  Данные в URL стоит использовать только для передачи информации, которая влияет на маршрут или контекст запроса, например, идентификатор ресурса или параметры фильтрации.

## Можно ли с помощью URLa передать данные на сервер?

**С помощью URL можно передавать данные на сервер**, используя параметры в строке запроса (query string). Это часто используется в HTTP-запросах, особенно с методом **GET**, но может быть применимо и к другим методам, включая **POST**. Вот как это работает:

### **Передача данных через URL**

1. **Строка запроса (Query String)**:

   -  Данные передаются в формате ключ=значение и добавляются к базовому URL после символа ?.

   -  Несколько пар ключ-значение разделяются амперсандом (&).

**Пример**:\
http\
GET /search?q=example&category=books HTTP/1.1

Host: [example.com](http://example.com)

1. В этом примере данные q=example и category=books передаются серверу через URL.

2. **Использование с другими методами**:

   -  Хотя наиболее типично передавать параметры через URL с методом GET, вы также можете использовать их с другими методами, например POST, PUT, или DELETE. В этом случае данные в URL используются для уточнения запроса или указания контекста, в то время как основное тело запроса может содержать другие данные.

**Пример POST с данными в URL и теле**:\
http\
POST /submit?userId=123 HTTP/1.1

Host: [example.com](http://example.com)

Content-Type: application/json

{

  "name": "John Doe",

  "email": "[john@example.com](mailto:john@example.com)"

}

### **Ограничения и рекомендации**

1. **Длина URL**:

   -  Браузеры и серверы могут ограничивать длину URL (обычно до нескольких тысяч символов). Это делает передачу больших объемов данных через URL неэффективной.

2. **Чувствительная информация**:

   -  Передача конфиденциальной информации (например, паролей, токенов) через URL небезопасна, так как она может быть видна в истории браузера, логах сервера или прокси-серверах.

3. **Кэширование**:

   -  Данные в URL могут кэшироваться браузерами или прокси-серверами, что может быть полезным для повторных запросов, но нежелательным для запросов с изменяемыми данными.

4. **Идемпотентность**:

   -  Передача данных через URL удобна для методов, которые не изменяют состояние сервера (например, GET), так как повторный запрос не приведет к изменению данных.

### **Примеры использования**

**Фильтрация и сортировка**:\
\
\
GET /products?category=electronics&sort=price_asc

**Пагинация**:\
http\
\
GET /products?page=2&limit=20

**Поиск**:\
http\
GET /search?q=laptop

Таким образом, передача данных через URL -- это эффективный способ передать небольшие и нечувствительные данные, особенно для запросов на чтение (например, GET). Однако для передачи больших объемов данных или чувствительной информации лучше использовать тело запроса с методами вроде POST.

## Что такое идемпотентность?

Идемпотентность -- это такое свойство операций, при котором, сколько бы раз ты ни повторял одну и ту же операцию, результат остаётся неизменным. Представь, что ты нажимаешь кнопку включения света. Если свет выключен, он включится. Но если ты нажмёшь её снова, свет не станет ярче или не начнёт мигать -- он просто останется включённым.

Вот так же и с идемпотентными операциями в программировании. Например, если ты делаешь PUT запрос, чтобы обновить данные пользователя, неважно, сколько раз ты отправишь этот запрос -- данные будут обновлены один раз и останутся такими же после повторных запросов. Это удобно, потому что если что-то пошло не так, можно просто попробовать снова, не боясь, что сервер что-то сломает или сделает лишнее.

В отличие от этого, POST -- неидемпотентный. Если отправить запрос на создание нового ресурса несколько раз, получится несколько новых ресурсов, каждый раз с новыми данными.

## В чем разница между безопасностью и идемпотентностью?

Безопасность и идемпотентность -- это два разных свойства операций, и вот как они отличаются:

### **Безопасность (Safety)**

Когда говорят, что операция "безопасна", это значит, что она **не изменяет состояние сервера**. То есть, если ты делаешь такой запрос, то ничего на сервере не поменяется. Самый типичный пример -- это **GET** запросы. Ты можешь запрашивать данные сколько угодно раз, и сервер от этого не начнёт добавлять новые записи или что-то менять. Вот пару примеров безопасных запросов:

-  **GET /users** -- возвращает список пользователей.

-  **GET /products** -- показывает каталог товаров.

**Ключевая идея**: безопасные запросы -- это те, которые ничего не "ломают" и не изменяют на сервере.

### **Идемпотентность (Idempotency)**

Идемпотентность, как мы уже обсуждали, связана с тем, что **повторное выполнение одной и той же операции приводит к одному и тому же результату**. Но! Это не значит, что операция не меняет данные. Она может менять их, но если ты сделаешь её несколько раз, результат останется таким же, как после первого раза.

Примеры идемпотентных операций:

-  **PUT /user/1** -- обновляет данные пользователя с ID 1. Сколько бы раз ты ни отправлял этот запрос с одними и теми же данными, данные на сервере останутся неизменными после первого выполнения.

-  **DELETE /user/1** -- удаляет пользователя с ID 1. Если пользователя нет, повторные запросы не изменят ничего дополнительно.

**Ключевая идея**: идемпотентные запросы могут изменять данные, но повторные запросы не приведут к дополнительным изменениям.

### **Сравнение**

-  **Безопасность** говорит о том, что запрос ничего не изменяет на сервере.

-  **Идемпотентность** говорит о том, что сколько бы раз ты ни выполнял запрос, результат будет одинаковым.

Пример:

-  **GET** -- безопасный и идемпотентный (ничего не меняет и всегда возвращает одно и то же для одного и того же запроса).

-  **PUT** -- идемпотентный, но не безопасный (изменяет данные, но повторные изменения дают тот же результат).

-  **POST** -- не безопасный и не идемпотентный (создаёт новый ресурс, и повторное выполнение создаёт ещё один новый ресурс).

## Что такое endpoint?

Эндпоинт -- это URL-адрес, по которому клиент (например, веб-приложение или мобильное приложение) может отправить запрос к серверу для получения или отправки данных. Эндпоинты используются в API (интерфейсах программирования приложений), чтобы структурировать взаимодействие между клиентом и сервером.

### **Примеры использования эндпоинтов:**

-  **Получение данных**: Например, эндпоинт GET /api/users может использоваться для получения списка всех пользователей.

-  **Создание новых данных**: Эндпоинт POST /api/users позволяет клиенту отправить данные для создания нового пользователя.

-  **Обновление существующих данных**: Эндпоинт PUT /api/users/1 используется для обновления информации о пользователе с ID 1.

-  **Удаление данных**: Эндпоинт DELETE /api/users/1 удаляет пользователя с ID 1.

Эндпоинты делают API организованными и понятными, позволяя разработчикам легко взаимодействовать с сервером.

## Что такое статус код сервера?

Статус-код сервера -- это трехзначное число, которое сервер возвращает в ответ на HTTP-запрос. Эти коды информируют клиента о результате обработки запроса и помогают понять, что произошло.

### **Группы статус-кодов:**

Статус-коды делятся на несколько групп, каждая из которых имеет своё значение:

1. **1xx (Информационные)**: Указывают на то, что запрос получен, и продолжается его обработка. Обычно используются реже.

2. **2xx (Успех)**: Указывают на успешное выполнение запроса. Например, 200 OK означает, что всё прошло хорошо.

3. **3xx (Перенаправление)**: Указывают, что нужно выполнить дополнительное действие для завершения запроса. Например, 301 Moved Permanently говорит о том, что ресурс был перемещён.

4. **4xx (Ошибки клиента)**: Указывают на ошибки, связанные с запросом клиента. Например, 404 Not Found означает, что запрашиваемый ресурс не найден.

5. **5xx (Ошибки сервера)**: Указывают на проблемы на стороне сервера. Например, 500 Internal Server Error говорит о том, что сервер столкнулся с неожиданной ошибкой.

### **Примеры статус-кодов из группы 4xx:**

1. **400 Bad Request**: Запрос не может быть обработан из-за неверного синтаксиса.

2. **401 Unauthorized**: Необходима аутентификация для доступа к ресурсу.

3. **403 Forbidden**: Доступ к ресурсу запрещён, даже если аутентификация успешна.

4. **404 Not Found**: Запрашиваемый ресурс не найден на сервере.

5. **408 Request Timeout**: Время ожидания запроса истекло.

### **Примеры статус-кодов из группы 5xx:**

1. **500 Internal Server Error**: Внутренняя ошибка сервера.

2. **501 Not Implemented**: Сервер не поддерживает функциональность, необходимую для обработки запроса.

3. **502 Bad Gateway**: Сервер, действующий как шлюз или прокси, получил недопустимый ответ от вышестоящего сервера.

4. **503 Service Unavailable**: Сервер временно недоступен, например, из-за перегрузки или технического обслуживания.

5. **504 Gateway Timeout**: Время ожидания ответа от вышестоящего сервера истекло

## Какие ты знаешь Headers в Request?

## Какие ты знаешь Headers в Responce?

## Из чего состоит запрос HTTP - реквест?

## Из чего состоят ответы HTTP -респонс?

## Идентификация, Аутентификация, Авторизация

## Что происходит при валидации на сервере

## Что происходит при валидации на клиенте

## Что такое токен

## Где хранится токен

## Что такое токен авторизации? Объясни процесс токен авторизации?

## Может ли быть авторизация без аутентификации? Приведи пример.

## Что такое куки?

## Что такое теплый клиент?

## Что такое холодный клиент?

## Что такое кеш?

## Для чего используется кэширование страниц?

## Для чего необходимо сбрасывать кэш и куки?

## Что такое сессия?

## Какие стореджи браузера ты знаешь?

## В чем разница между сешин сторедж и локал сторедж?

## Для чего необходимо сбрасывать кэш и куки?

## Что такое REST

## Что такое SOAP

## Чем REST отличается от SOAP?

## JSON Schema - это?

## Что такое JSON и XML?

## Каким форматом данных могут быть ключи в JSON?

## Каким форматом данных могут быть значения в JSON?

## Какие невалидные типы данных есть у JSON?

## Что такое WSDL

## Что такое WADL

## Что такое логи?

## Что такое логирование?

## Перечислите типы логов

## Механизм записи информации в логи

## Зачем нужны логи? Какие инструменты знаете для сбора логов?

## Привести примеры, когда QA-специалисту необходимо собрать логи с помощью Kibana

## Что такое DNS?

## Что такое IP адрес?

## Что такое порт?

## Что такое хост?

## Что такое URL

## В чем разница между URI, URL, URN ?

## Из чего состоит url адрес?

## Что происходит после ввода запроса в адресную строку?

## Что такое HTTP/HTTPS 

HTTP (Hypertext Transfer Protocol) и HTTPS (Hypertext Transfer Protocol Secure) -- это протоколы, используемые для передачи данных в сети интернет. Они лежат в основе взаимодействия между клиентами (например, браузерами) и серверами, обеспечивая загрузку веб-страниц, передачу данных и выполнение других операций.

### **HTTP**

**HTTP** -- это незащищённый протокол передачи данных, который позволяет клиентам и серверам обмениваться информацией. Он работает по принципу «запрос-ответ». Когда пользователь вводит URL в браузере, браузер отправляет HTTP-запрос на сервер, который затем возвращает ответ, содержащий запрашиваемую информацию. Этот процесс включает следующие ключевые аспекты:

1. **Запросы и ответы**: HTTP-запросы могут быть различных типов, включая GET (для получения данных), POST (для отправки данных), PUT (для обновления данных) и DELETE (для удаления данных). Сервер обрабатывает запрос и возвращает ответ, который включает статус (например, 200 OK для успешного запроса) и саму информацию (HTML-код, изображения и т.д.).

2. **Статусы**: Каждый HTTP-ответ имеет статусный код, который сообщает о результате запроса. Например, 404 означает, что запрашиваемая страница не найдена, а 500 -- о внутренней ошибке сервера.

3. **Текстовый протокол**: HTTP -- текстовый протокол, что означает, что запросы и ответы читаемы для человека. Они состоят из строк текста, которые описывают действия и содержимое.

4. **Безопасность**: HTTP не обеспечивает шифрование данных, что делает его уязвимым для атак, таких как перехват трафика. Это значит, что передаваемые данные могут быть легко прочитаны злоумышленниками, если они получают доступ к сети.

### **HTTPS**

**HTTPS** -- это защищённая версия HTTP, которая добавляет уровень безопасности с помощью шифрования. Это достигается за счёт использования протокола SSL (Secure Sockets Layer) или его более современного аналога, TLS (Transport Layer Security). Основные характеристики HTTPS:

1. **Шифрование**: При использовании HTTPS данные между клиентом и сервером шифруются, что делает их недоступными для посторонних. Это предотвращает возможность перехвата и анализа трафика, что особенно важно для передачи конфиденциальной информации, такой как пароли и номера кредитных карт.

2. **Аутентификация**: HTTPS обеспечивает аутентификацию сервера. Это означает, что клиент может быть уверен, что он соединяется именно с тем сервером, к которому он пытается подключиться, а не с поддельным. Это достигается с помощью цифровых сертификатов, которые выдаются авторитетными центрами сертификации (CA).

3. **Интегритет данных**: HTTPS гарантирует целостность данных. Это означает, что информация не может быть изменена или подменена во время передачи. Если данные были изменены, клиент получит ошибку, что указывает на потенциальную проблему с безопасностью.

4. **Пользовательский опыт**: Современные браузеры отмечают сайты, использующие HTTPS, как безопасные. На таких сайтах в адресной строке отображается значок замка, что даёт пользователям уверенность в безопасности их данных. В некоторых случаях поисковые системы, такие как Google, отдают предпочтение сайтам с HTTPS в результатах поиска.

### **Сравнение HTTP и HTTPS**

{% table %}

---

*  **Параметр**

*  **HTTP**

*  **HTTPS**

---

*  Безопасность

*  Не защищён

*  Защищён

---

*  Шифрование

*  Нет

*  Да

---

*  Аутентификация

*  Нет

*  Да

---

*  Целостность данных

*  Нет

*  Да

---

*  Использование

*  Подходит для открытых данных

*  Рекомендуется для конфиденциальных данных

{% /table %}

### **Применение**

HTTP используется для большинства открытых веб-страниц, где нет необходимости в защите данных. Однако HTTPS рекомендуется для любых сайтов, обрабатывающих чувствительную информацию, таких как интернет-магазины, банковские услуги, социальные сети и любые другие сервисы, где важна безопасность и конфиденциальность данных.

Таким образом, HTTP и HTTPS играют критическую роль в веб-технологиях. HTTPS становится стандартом для всех веб-сайтов, обеспечивая безопасность данных и доверие пользователей.

## SSL и TLS - это?

## TCP/IP - это?

## Уровни TCP/IP?

## Уровни OSI?

## Что такое FTP?

## Какую структуру имеет веб-страница?

## Что такое HTML/CSS/JavaScript?

## Что такое AJAX?

## Что такое адаптивная и респонсивная верстка?

## Как протестировать адаптивную верстку?

## Как выполнить Debug страницы в браузере?

## Что такое WebSocket и как проверить обрыв соединения?

## Как узнать схему API проекта

## Можно ли начать тестирование, если интерфейс (frontend) ещё не готов? Как?

## Какие виды тестирования можно применить только к Web?

## Каковы есть основные виды уязвимости веб-приложений?

## Какие инструменты для тестирования Web performance client-side знаете?
